import nme.display.Sprite;import nme.display.Bitmap;import nme.display.BitmapData;import nme.text.TextField;import nme.events.Event;import nme.events.TimerEvent;import nme.utils.Timer;import nme.geom.Matrix;import nme.geom.Rectangle;import nme.utils.ByteArray;class MandelbrotByteArray{    public static function main() : Void    {        new MandelbrotByteArray();    }        public var pixels:Array<Array<Int>>;    public var pixelsba:ByteArray;        public var colorModifier:Int;    private var bitmapData:BitmapData;    private var bigBitmapData:BitmapData;        private var fps:TextField;        private var width:Int;    private var height:Int;    private var matrix:Matrix;        public function new()     {        width = 320;        height = 240;            var scale:Float = 2;        matrix = new Matrix();        matrix.scale(scale, scale);        var setBitmap:Bitmap = new Bitmap();        bitmapData = new BitmapData( width , height , false , 0x000000 );        bigBitmapData = new BitmapData( nme.Lib.current.stage.stageWidth , nme.Lib.current.stage.stageHeight , false , 0x000000 );                setBitmap.bitmapData = bigBitmapData;                nme.Lib.current.addChild( setBitmap );                var maxIterations:Int = 128;                pixels = new Array();        pixelsba = new ByteArray();        //pixelsba.setLength(width*height*4);        var beforeTime = nme.Lib.getTimer();                var xtemp;        var iteration;        var x0:Float = 0;        var y0:Float = 0;        for(ix in 0...width) {            pixels[ix] = new Array();            for(iy in 0...height) {                    x0 = 0;                    y0 = 0;                    iteration = 128;                                        while ( x0*x0 + y0*y0 <= 4  &&  iteration > 0 )                     {                        xtemp = x0*x0 - y0*y0 + (ix-14*5000)/50000;                        y0 = 2*x0*y0 + (iy-(height/0.6))/50000;                        x0 = xtemp;                                                iteration--;                    }                                        pixels[ix][iy] = iteration;                               }        }                var afterTime = nme.Lib.getTimer();                var tf = new TextField();        tf.width = 400;        tf.text = "Generating fractal took "+(afterTime-beforeTime)+" ms";        nme.Lib.current.addChild(tf);                fps = new TextField();        fps.width = 400;        fps.y = 10;        fps.text = "FPS: ";        nme.Lib.current.addChild(fps);                  colorModifier = 2;        var timer:haxe.Timer = new haxe.Timer(10);                runLoop();        timer.run = runLoop;    }        public function runLoop() {        var r:Int=0, b:Int=0, g:Int=0;        var pixel:Int = 0;                var beforeTime = nme.Lib.getTimer();                for(iy in 0...height) {            for(ix in 0...width) {                pixel = pixels[ix][iy];                r = pixel + colorModifier;                g = pixel + colorModifier + r;                b = pixel + colorModifier + g;                                pixelsba[(ix+iy*width)*4] = 0;                pixelsba[(ix+iy*width)*4 + 1] = r;                pixelsba[(ix+iy*width)*4 + 2] = g;                pixelsba[(ix+iy*width)*4 + 3] = b;                            }        }        pixelsba.position = 0;        var rect = new nme.geom.Rectangle(0,0,width,height);        bitmapData.setPixels(rect, pixelsba);        bigBitmapData.draw(bitmapData, matrix, null, null, null, false);               var afterTime = nme.Lib.getTimer();        fps.text = "FPS: "+Math.round(1000/(afterTime-beforeTime));                colorModifier += 2;        if(colorModifier > 65530)                colorModifier = 0;            }}